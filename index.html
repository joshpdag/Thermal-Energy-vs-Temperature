<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Volume vs Temperature Change</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 1400px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .simulation-container {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        #particleCanvas {
            border: 3px solid #ddd;
            border-radius: 10px;
            background-color: #ffffff !important;
            display: block;
            margin: 0 auto;
        }
        
        .graph-container {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        #graphCanvas {
            border: 2px solid #ddd;
            border-radius: 10px;
            background: white;
            display: block;
            margin: 0 auto;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-section {
            background: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: 2px solid #f0f0f0;
        }
        
        .section-title {
            font-size: 1em;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #eee;
            text-align: center;
        }
        
        .control-group {
            margin-bottom: 12px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
            color: #444;
            font-size: 0.9em;
        }
        
        select, button, input {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #ddd;
            font-size: 1em;
            transition: all 0.3s ease;
        }
        
        select, input {
            background: white;
            cursor: pointer;
        }
        
        select:hover, input:hover {
            border-color: #667eea;
        }
        
        input {
            text-align: center;
            font-family: 'Courier New', monospace;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .legend {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .legend h3 {
            margin-bottom: 10px;
            color: #444;
        }
        
        .legend-items {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .color-box {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 2px solid #ddd;
        }
        
        .info-panel {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #2196F3;
            margin-bottom: 20px;
        }
        
        .info-panel h3 {
            color: #1976D2;
            margin-bottom: 8px;
        }
        
        .info-panel p {
            color: #555;
            line-height: 1.6;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            gap: 10px;
        }
        
        .stat-box {
            background: white;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            flex: 1;
        }
        
        .timer-box {
            background: white;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 120px;
        }
        
        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 4px;
            font-weight: bold;
        }
        
        .stat-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
            font-family: 'Courier New', monospace;
            margin-bottom: 3px;
        }
        
        .energy-value {
            font-size: 0.9em;
            color: #0066cc;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .volume-label {
            font-size: 0.8em;
            color: #888;
            margin-top: 2px;
        }
        
        .reset-button {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }
        
        .reset-button:hover {
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üå°Ô∏è Volume vs Temperature Change - UPDATED</h1>
        <p class="subtitle">Watch how different volumes of hot water cool down at different rates</p>
        
        <div class="info-panel">
            <h3>üî¨ How to Use This Simulation</h3>
            <p>
                <strong>1.</strong> Watch four containers with different volumes<br>
                <strong>2.</strong> Choose hot water (cools down) or cool water (warms up)<br>
                <strong>3.</strong> Observe particle colors showing kinetic energy levels
            </p>
        </div>
        
        <div class="controls">
            <div class="control-section">
                <div class="section-title">‚èØÔ∏è Simulation Controls</div>
                <div class="control-group">
                    <label>Animation:</label>
                    <button id="startStop">‚ñ∂Ô∏è START COOLING</button>
                </div>
                
                <div class="control-group">
                    <label>Speed:</label>
                    <button id="speedToggle">üèÉ NORMAL SPEED</button>
                </div>
                
                <div class="control-group">
                    <label for="initialTemp">Water Temperature:</label>
                    <select id="initialTemp">
                        <option value="180">180¬∞F (Hot - Cools Down)</option>
                        <option value="40">40¬∞F (Cold - Warms Up)</option>
                    </select>
                </div>
            </div>
            
            <div class="control-section">
                <div class="section-title">üîÑ Reset Options</div>
                <div class="control-group">
                    <label>Reset Simulation:</label>
                    <button id="reset" class="reset-button">üîÑ RESET TO START</button>
                </div>
                
                <div class="control-group">
                    <label>Clear Graph:</label>
                    <button id="clearGraph">üìä CLEAR GRAPH</button>
                </div>
                
                <div class="control-group">
                    <label for="coolingRate">Cooling Rate:</label>
                    <select id="coolingRate">
                        <option value="slow">Slow</option>
                        <option value="normal" selected>Normal</option>
                        <option value="fast">Fast</option>
                    </select>
                </div>
            </div>
            
            <div class="control-section">
                <div class="section-title">üìä Graph Controls</div>
                <div class="control-group">
                    <label>Graph Display:</label>
                    <button id="togglePause">‚è∏Ô∏è PAUSE GRAPH</button>
                </div>
            </div>
        </div>
        
        <div class="legend">
            <h3>Atom Speed & Kinetic Energy Color Scale</h3>
            <div class="legend-items">
                <div class="legend-item">
                    <div class="color-box" style="background: #ff0000;"></div>
                    <span>Very High KE (Fast)</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: #ff8800;"></div>
                    <span>High KE (Medium-Fast)</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: #ffff00;"></div>
                    <span>Medium KE (Medium)</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: #00ff00;"></div>
                    <span>Low KE (Slow)</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: #0088ff;"></div>
                    <span>Very Low KE (Very Slow)</span>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="simulation-container">
                <canvas id="particleCanvas" width="800" height="400"></canvas>
                
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">50 ml Cup</div>
                        <div class="stat-value" id="temp1">180¬∞F</div>
                        <div class="energy-value" id="energy1">4500 KE units</div>
                        <div class="volume-label">25 atoms</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">100 ml Cup</div>
                        <div class="stat-value" id="temp2">180¬∞F</div>
                        <div class="energy-value" id="energy2">9000 KE units</div>
                        <div class="volume-label">50 atoms</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">200 ml Cup</div>
                        <div class="stat-value" id="temp3">180¬∞F</div>
                        <div class="energy-value" id="energy3">18000 KE units</div>
                        <div class="volume-label">100 atoms</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">500 ml Cup</div>
                        <div class="stat-value" id="temp4">180¬∞F</div>
                        <div class="energy-value" id="energy4">45000 KE units</div>
                        <div class="volume-label">250 atoms</div>
                    </div>
                    <div class="timer-box">
                        <div class="stat-label">Simulation Time</div>
                        <div class="stat-value" id="timer">0.0s</div>
                        <div class="volume-label">elapsed</div>
                    </div>
                </div>
            </div>
            
            <div class="graph-container">
                <div style="margin-bottom: 15px;">
                    <h3 style="margin: 0; color: #444; text-align: center;">Temperature Changes Over Time</h3>
                </div>
                <canvas id="graphCanvas" width="800" height="350"></canvas>
            </div>
        </div>
    </div>
    
    <script>
        let sim = null;
        
        class Atom {
            constructor(x, y, container, initialTemp = 80) {
                this.x = x;
                this.y = y;
                this.container = container;
                this.temperature = initialTemp;
                this.kineticEnergy = initialTemp;
                this.radius = 3;
                
                this.setVelocityFromKE();
            }
            
            setVelocityFromKE() {
                const maxSpeed = (this.temperature / 100) * 3;
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * maxSpeed;
                this.vy = Math.sin(angle) * maxSpeed;
            }
            
            update(speedMult, coolingRate, sim) {
                const volume = sim.containers[this.container].volume;
                const surfaceAreaRatio = 1 / Math.pow(volume, 0.33);
                const roomTemp = 70; // Room temperature is 70¬∞F
                
                // Calculate temperature difference between water and room
                const tempDifference = this.temperature - roomTemp;
                
                // Energy flows toward equilibrium (room temperature)
                let energyChangeRate = 0.02 * surfaceAreaRatio * coolingRate;
                
                if (tempDifference > 0) {
                    // Water is hotter than room - loses energy (cools down)
                    this.kineticEnergy = Math.max(roomTemp, this.kineticEnergy - energyChangeRate);
                } else if (tempDifference < 0) {
                    // Water is cooler than room - gains energy (warms up)
                    this.kineticEnergy = Math.min(roomTemp, this.kineticEnergy + energyChangeRate);
                }
                
                this.temperature = this.kineticEnergy;
                this.setVelocityFromKE();
                
                this.x += this.vx * speedMult;
                this.y += this.vy * speedMult;
                
                const bounds = this.getContainerBounds(sim);
                
                if (this.x - this.radius <= bounds.left || this.x + this.radius >= bounds.right) {
                    this.vx *= -0.9;
                    this.x = Math.max(bounds.left + this.radius, Math.min(bounds.right - this.radius, this.x));
                }
                if (this.y - this.radius <= bounds.top || this.y + this.radius >= bounds.bottom) {
                    this.vy *= -0.9;
                    this.y = Math.max(bounds.top + this.radius, Math.min(bounds.bottom - this.radius, this.y));
                }
            }
            
            getContainerBounds(sim) {
                const containerWidth = 180;
                const containerHeight = 280;
                const startX = this.container * 200 + 10;
                const startY = 100;
                
                const maxVolume = 500;
                const volume = sim ? sim.containers[this.container].volume : [50, 100, 200, 500][this.container];
                const waterHeightRatio = Math.min(1, volume / maxVolume);
                const waterHeight = containerHeight * waterHeightRatio;
                const waterTop = startY + containerHeight - waterHeight;
                
                return {
                    left: startX + 5,
                    right: startX + containerWidth - 5,
                    top: waterTop + 5,
                    bottom: startY + containerHeight - 5
                };
            }
            
            getColor() {
                const temp = this.temperature;
                if (temp > 140) return '#ff0000';      // Very hot red (140¬∞F+)
                if (temp > 100) return '#ff8800';      // Hot orange (100-140¬∞F)
                if (temp > 70) return '#ffff00';       // Warm yellow (70-100¬∞F) - room temp and above
                if (temp > 50) return '#00ff00';       // Cool green (50-70¬∞F)
                return '#0088ff';                      // Cold blue (below 50¬∞F)
            }
        }
        
        class VolumeSimulation {
            constructor() {
                this.canvas = document.getElementById('particleCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.graphCanvas = document.getElementById('graphCanvas');
                this.graphCtx = this.graphCanvas.getContext('2d');
                
                this.containers = [
                    { volume: 50, atoms: [], atomCount: 25, name: "50 ml" },
                    { volume: 100, atoms: [], atomCount: 50, name: "100 ml" },
                    { volume: 200, atoms: [], atomCount: 100, name: "200 ml" },
                    { volume: 500, atoms: [], atomCount: 250, name: "500 ml" }
                ];
                
                this.running = false;
                this.speedMode = 'normal';
                this.time = 0;
                this.graphData = [];
                this.colors = ['#ff4444', '#4444ff', '#44ff44', '#ff44ff'];
                this.graphPaused = false;
                this.autoScale = false;
                
                this.initAtoms();
                this.setupEventListeners();
                this.updateStats();
                this.draw();
                this.drawGraph();
            }
            
            initAtoms() {
                const initialTemp = parseInt(document.getElementById('initialTemp').value);
                
                this.containers.forEach((container, containerIndex) => {
                    container.atoms = [];
                    const containerWidth = 180;
                    const containerHeight = 280;
                    const startX = containerIndex * 200 + 20;
                    const startY = 110;
                    
                    const maxVolume = 500;
                    const waterHeightRatio = Math.min(1, container.volume / maxVolume);
                    const waterHeight = containerHeight * waterHeightRatio;
                    const waterTop = startY + containerHeight - waterHeight;
                    
                    for (let i = 0; i < container.atomCount; i++) {
                        const x = startX + Math.random() * (containerWidth - 20);
                        const y = waterTop + 10 + Math.random() * (waterHeight - 20);
                        container.atoms.push(new Atom(x, y, containerIndex, initialTemp));
                    }
                });
                
                this.time = 0;
                this.graphData = [];
            }
            
            setupEventListeners() {
                document.getElementById('startStop').addEventListener('click', () => {
                    this.running = !this.running;
                    document.getElementById('startStop').textContent = 
                        this.running ? '‚è∏Ô∏è PAUSE' : '‚ñ∂Ô∏è START ANIMATION';
                    if (this.running) this.animate();
                });
                
                document.getElementById('speedToggle').addEventListener('click', () => {
                    if (this.speedMode === 'normal') {
                        this.speedMode = 'slow';
                        document.getElementById('speedToggle').textContent = 'üê¢ SLOW MOTION';
                    } else if (this.speedMode === 'slow') {
                        this.speedMode = 'fast';
                        document.getElementById('speedToggle').textContent = '‚ö° FAST SPEED';
                    } else {
                        this.speedMode = 'normal';
                        document.getElementById('speedToggle').textContent = 'üèÉ NORMAL SPEED';
                    }
                });
                
                document.getElementById('reset').addEventListener('click', () => {
                    this.running = false;
                    document.getElementById('startStop').textContent = '‚ñ∂Ô∏è START ANIMATION';
                    this.speedMode = 'normal';
                    document.getElementById('speedToggle').textContent = 'üèÉ NORMAL SPEED';
                    this.initAtoms();
                    this.updateStats();
                    this.draw();
                    this.drawGraph();
                });
                
                document.getElementById('clearGraph').addEventListener('click', () => {
                    this.graphData = [];
                    this.time = 0;
                    this.drawGraph();
                });
                
                document.getElementById('togglePause').addEventListener('click', () => {
                    this.graphPaused = !this.graphPaused;
                    document.getElementById('togglePause').textContent = 
                        this.graphPaused ? '‚ñ∂Ô∏è RESUME GRAPH' : '‚è∏Ô∏è PAUSE GRAPH';
                });
                
                document.getElementById('initialTemp').addEventListener('change', () => {
                    if (!this.running) {
                        this.initAtoms();
                        this.updateStats();
                        this.draw();
                        this.drawGraph();
                    }
                });
            }
            
            animate() {
                if (!this.running) return;
                
                let speedMult;
                switch(this.speedMode) {
                    case 'slow': speedMult = 0.3; break;
                    case 'fast': speedMult = 2.0; break;
                    default: speedMult = 1.0;
                }
                
                const coolingRateSelect = document.getElementById('coolingRate');
                let coolingRate = 1.0;
                if (coolingRateSelect) {
                    switch(coolingRateSelect.value) {
                        case 'slow': coolingRate = 0.5; break;
                        case 'fast': coolingRate = 2.0; break;
                        default: coolingRate = 1.0;
                    }
                }
                
                this.containers.forEach(container => {
                    container.atoms.forEach(atom => {
                        atom.update(speedMult, coolingRate, this);
                    });
                });
                
                this.draw();
                
                if (this.time % 30 === 0) {
                    this.updateStats();
                    if (!this.graphPaused) {
                        this.recordTemperatures();
                        this.drawGraph();
                    }
                }
                
                this.time++;
                requestAnimationFrame(() => this.animate());
            }
            
            draw() {
                // Clear canvas and explicitly reset all properties
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Explicit full canvas property reset
                this.ctx.globalAlpha = 1.0;
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.fillStyle = '#ffffff';
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 1;
                this.ctx.lineCap = 'butt';
                this.ctx.lineJoin = 'miter';
                this.ctx.font = '10px sans-serif';
                this.ctx.textAlign = 'start';
                this.ctx.textBaseline = 'alphabetic';
                
                // Fill entire canvas with white to ensure clean background
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.save(); // Save the clean state
                
                this.containers.forEach((container, index) => {
                    this.ctx.save(); // Save state before each container
                    
                    const x = index * 200 + 10;
                    const y = 100;
                    const width = 180;
                    const height = 280;
                    
                    const maxVolume = 500;
                    const waterHeightRatio = Math.min(1, container.volume / maxVolume);
                    const waterHeight = height * waterHeightRatio;
                    const waterTop = y + height - waterHeight;
                    
                    // Draw container outline
                    this.ctx.strokeStyle = '#333';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(x, y, width, height);
                    
                    // Draw water background - always light blue regardless of temperature
                    this.ctx.fillStyle = '#e6f3ff';
                    this.ctx.fillRect(x + 2, waterTop, width - 4, waterHeight - 2);
                    
                    // Draw water level line
                    this.ctx.strokeStyle = '#4a90e2';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + 5, waterTop);
                    this.ctx.lineTo(x + width - 5, waterTop);
                    this.ctx.stroke();
                    
                    // Draw labels
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(container.name, x + width/2, y - 10);
                    
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText(`${container.atomCount} atoms`, x + width/2, y + height + 20);
                    
                    this.ctx.restore(); // Restore state after each container
                });
                
                // Draw atoms on top of everything else
                this.containers.forEach(container => {
                    container.atoms.forEach(atom => {
                        this.ctx.save(); // Save state before each atom
                        this.ctx.fillStyle = atom.getColor();
                        this.ctx.beginPath();
                        this.ctx.arc(atom.x, atom.y, atom.radius, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.restore(); // Restore state after each atom
                    });
                });
                
                this.ctx.restore(); // Restore to the original clean state
            }
            
            updateStats() {
                this.containers.forEach((container, index) => {
                    if (container.atoms.length > 0) {
                        const totalKE = container.atoms.reduce((sum, atom) => sum + atom.kineticEnergy, 0);
                        const avgTemp = totalKE / container.atoms.length;
                        
                        const tempElement = document.getElementById(`temp${index + 1}`);
                        const energyElement = document.getElementById(`energy${index + 1}`);
                        
                        if (tempElement) {
                            tempElement.textContent = `${avgTemp.toFixed(1)}¬∞F`;
                        }
                        if (energyElement) {
                            energyElement.textContent = `${Math.round(totalKE)} KE units`;
                        }
                    }
                });
                
                const timerElement = document.getElementById('timer');
                if (timerElement) {
                    const seconds = this.time / 30;
                    timerElement.textContent = `${seconds.toFixed(1)}s`;
                }
            }
            
            recordTemperatures() {
                const data = this.containers.map(container => {
                    if (container.atoms.length === 0) return 80;
                    const totalKE = container.atoms.reduce((sum, atom) => sum + atom.kineticEnergy, 0);
                    return totalKE / container.atoms.length;
                });
                
                this.graphData.push(data);
                if (this.graphData.length > 600) {
                    this.graphData.shift();
                }
            }
            
            drawGraph() {
                const ctx = this.graphCtx;
                const width = this.graphCanvas.width;
                const height = this.graphCanvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                // Draw grid lines
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(50, height * i / 10);
                    ctx.lineTo(width - 20, height * i / 10);
                    ctx.stroke();
                }
                
                // Draw axes
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(50, 20);
                ctx.lineTo(50, height - 40);
                ctx.lineTo(width - 20, height - 40);
                ctx.stroke();
                
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                
                // Y-axis labels
                if (this.autoScale && this.graphData.length > 0) {
                    let minTemp = 999, maxTemp = -999;
                    this.graphData.forEach(dataPoint => {
                        dataPoint.forEach(temp => {
                            minTemp = Math.min(minTemp, temp);
                            maxTemp = Math.max(maxTemp, temp);
                        });
                    });
                    
                    const tempRange = maxTemp - minTemp;
                    const padding = tempRange * 0.1;
                    minTemp -= padding;
                    maxTemp += padding;
                    
                    ctx.fillText(`${maxTemp.toFixed(0)}¬∞F`, 10, 25);
                    ctx.fillText(`${((maxTemp + minTemp) / 2).toFixed(0)}¬∞F`, 15, height/2);
                    ctx.fillText(`${minTemp.toFixed(0)}¬∞F`, 15, height - 45);
                } else {
                    ctx.fillText('200¬∞F', 10, 25);
                    ctx.fillText('110¬∞F', 15, height/2);
                    ctx.fillText('20¬∞F', 15, height - 45);
                }
                
                // X-axis labels
                ctx.fillText('0s', 50, height - 15);
                ctx.fillText('300s', width/2 - 10, height - 15);
                ctx.fillText('600s', width - 50, height - 15);
                ctx.fillText('Time', width/2 - 15, height - 10);
                ctx.fillText('Temperature', 10, 15);
                
                // Draw data lines
                if (this.graphData.length > 1) {
                    const graphWidth = width - 70; // Available width for graph
                    const maxTime = 600; // 600 seconds = 20 minutes
                    
                    this.containers.forEach((container, containerIndex) => {
                        ctx.strokeStyle = this.colors[containerIndex];
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        
                        let hasStarted = false;
                        
                        for (let i = 0; i < this.graphData.length; i++) {
                            // Fixed x-position based on actual time
                            const timeInSeconds = i; // Since we record every second
                            const x = 50 + (timeInSeconds / maxTime) * graphWidth;
                            
                            // Only draw points that fit within our time window
                            if (x <= width - 20) {
                                let normalizedTemp;
                                if (this.autoScale && this.graphData.length > 0) {
                                    let minTemp = 999, maxTemp = -999;
                                    this.graphData.forEach(dataPoint => {
                                        dataPoint.forEach(temp => {
                                            minTemp = Math.min(minTemp, temp);
                                            maxTemp = Math.max(maxTemp, temp);
                                        });
                                    });
                                    
                                    const tempRange = maxTemp - minTemp;
                                    const padding = tempRange * 0.1;
                                    minTemp -= padding;
                                    maxTemp += padding;
                                    
                                    const value = this.graphData[i][containerIndex];
                                    normalizedTemp = Math.max(0, Math.min(1, (value - minTemp) / (maxTemp - minTemp)));
                                } else {
                                    const tempRange = 200 - 20;
                                    const value = this.graphData[i][containerIndex];
                                    normalizedTemp = Math.max(0, Math.min(1, (value - 20) / tempRange));
                                }
                                
                                const y = height - 50 - (normalizedTemp * (height - 70));
                                
                                if (!hasStarted) {
                                    ctx.moveTo(x, y);
                                    hasStarted = true;
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            }
                        }
                        ctx.stroke();
                    });
                }
                
                // Legend
                this.containers.forEach((container, index) => {
                    const legendY = 30 + index * 25;
                    ctx.fillStyle = this.colors[index];
                    ctx.fillRect(width - 150, legendY, 20, 3);
                    ctx.fillStyle = '#333';
                    ctx.font = '11px Arial';
                    ctx.fillText(`${container.name} (${container.atomCount} atoms)`, width - 125, legendY + 5);
                });
            }
        }
        
        // Initialize simulation when page loads
        document.addEventListener('DOMContentLoaded', () => {
            sim = new VolumeSimulation();
        });
    </script>
</body>
</html>
